% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen-list.r
\name{gen.list}
\alias{gen.list}
\alias{gen.vector}
\alias{gen.data.frame}
\alias{gen.matrix}
\title{Generate Lists, Vectors and Data Frames with List Comprehension}
\usage{
gen.list(expr, ...)

gen.vector(expr, ...)

gen.data.frame(expr, ...)

gen.matrix(expr, ...)
}
\arguments{
\item{expr}{A base expression containing free variables which is evaluated for all combinations of variables, 
  where the combinations of variables are given by the ranges and conditions (see \code{...} parameters).

Expected structure of \code{expr}:
 \itemize{
   \item For \code{gen.list} it may have arbitrary structure (including a list).
   \item For \code{gen.vector} a value (i.e., a vector of length 1) is expected.
   \item For \code{gen.data.frame} and \code{gen.matrix} a (named) vector or list is expected which describes one row of the data frame.
  }
  Within \code{expr} it is allowed to use functions and predefined constants from the parent environment.}

\item{...}{Arbitrary many variable ranges and conditions.
For all free variables occurring in \code{expr} a range must be assigned, e.g., \code{x = 1:3, y = 1:5} for an expression \code{x + y}. 
At least one variable range is required.
The ranges may depend on each other, e.g., \code{x = 1:3, y = x:3} or a substitution like \code{x = 1:3, y = 2 * x} is allowed.
The generated values can be further restricted by conditions (like \code{x <= y}).}
}
\value{
The result of \code{gen.list} is a list (a vector for \code{gen.vector}) containing an entry for each combination of the free variables (i.e., the Cartesian product), where all the free variables in \code{expr} are substituted.
The function \code{gen.vector} returns a vector while \code{gen.list} may contain also more complex substructures (like vectors or lists).

The output of \code{gen.data.frame} is a data frame where each substituted \code{expr} entry is one row.
The base expression \code{expr} should contain a (named) vector or list, such that each entry of this vector becomes a column of the returned data frame.
If the vector contains a single literal without a name, this is taken as column name. For instance, \code{gen.data.frame(a, a = 1:5)} returns the same as \code{gen.data.frame(c(a = a), a = 1:5)}.
Default names 'V1', 'V2', ... are used, if no names are given and names can't be automatically detected.

The result of \code{gen.matrix} is a matrix where each substituted \code{expr} entry is one row.
It works similar to \code{gen.data.frame}.
In contrast to that, column names are not auto-generated, e.g., \code{gen.matrix(c(a_1, a_2), a_ = 1:2)} is an unnamed matrix.
If the \code{expr} argument has explicit names (e.g., \code{c(a_1 = a_1, a_2 = a_2)}), these column names are assigned to the resulting matrix.

All expressions and conditions are applied to each combination of the free variables separately, i.e., they are applied row-wise and not vector-wise. 
For instance, the term \code{sum(x,y)} (within \code{expr} or a condition) is equivalent to \code{x+y}.
}
\description{
Functions to transform a base expression containing free variables into a list, a vector, or a data frame
based on variable ranges and additional conditions.
}
\section{Syntactic Features}{
 

There are several syntactic features to be used in variable ranges, conditions, and expressions.

A range for a variable ending with an underscore (like \code{x_}) defines a set of ranges affecting all variables named \code{{varname}_{index}}, e.g. \code{x_1}.
For instance, in \code{gen.vector(x_1 + x_2 + x_3, x_ = 1:5)} the variables \code{x_1, x_2, x_3} are all ranging in \code{1:5}.
This can be overwritten for each single \code{x_i}, e.g., an additional argument \code{x_3 = 1:3} assigns the range \code{1:3} to \code{x_3} while \code{x_1} and \code{x_2} keep the range \code{1:5}.
A group of indexed variables is kept always sorted according to the position of the main variable \code{{varname}_}. 
For instance, the two following statements produce the same results:
  
\itemize{
  \item \code{gen.vector(x_1 + x_2 + a, x_ = 1:5, a = 1:2, x_1 = 1:2)}
  \item \code{gen.vector(x_1 + x_2 + a, x_1 = 1:2, x_2 = 1:5, a = 1:2)}
}

Expressions and conditions support a \code{...}-notation which works as follows:

\itemize{
  \item A vector like \code{c(x_1, ..., x_4)} is a shortcut for \code{c(x_1, x_2, x_3, x_4)}. 
  \item A named vector like \code{c(a_1 = x_1, ..., a_3 = x_3)} is a shortcut for \code{c(a_1 = x_1, a_2 = x_2, a_3 = x_3)}. 
  \item A n-ary function argument like \code{sum(x_1, ..., x_4)} is a shortcut for \code{sum(x_1, x_2, x_3, x_4)}.
  \item Repeated expressions of binary operators can be abbreviated with the \code{...} expressions as follows:
    \code{x_1 + ... + x_4} is a shortcut for \code{x_1 + x_2 + x_3 + x_4}. 
    Note that, due to operator precedence, \code{1 + x_1 + ... + x_4} will not work, but \code{1 + (x_1 + ... + x_4)} works as expected.
  \item For non-commutative operators, \code{x_1 - ... - x_4} is a shortcut for \code{x_1 - x_2 - x_3 - x_4} which is evaluated as \code{((x_1 - x_2) - x_3) - x_4}.
}

The conditions may contain itself list comprehension expressions, e.g., \code{\link{gen.logical.and}} to compose and-connected logical expressions.
}

\examples{
# Compose 10, 11, 20, 21, 22, 30, ..., 33, ..., 90, ..., 99 into a vector
gen.vector(x * 10 + y, x = 1:9, y = 1:x)

# A list containing vectors [1], [1, 2], [1, 2, 3], ...
gen.list(gen.vector(i, i = 1:n), n = 1:10)

# A data frame of tuples (x_1, x_2, x_3) summing up to 10
gen.data.frame(c(x_1, ..., x_3), x_ = 1:10, x_1 + ... + x_3 == 10)

# A data.frame containing the numbers in 2:20, the sum of their divisors
# and a flag if they are "perfect" (sum of divisors equals the number)
gen.data.frame(c(n, sumdiv, perfect = (n == sumdiv)), n = 2:20, 
               sumdiv = sum(gen.vector(x, x = 1:(n-1), n \%\% x == 0)))

}
\seealso{
\code{\link{gen.list.expr}} to generate expressions to be evaluated later, 
  \code{\link{gen.list.char}} to generate lists of characters, 
  and \link{listcompr} for an overview of all list comprehension functions.
}
